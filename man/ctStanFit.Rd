% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/ctStanFit.R
\name{ctStanFit}
\alias{ctStanFit}
\title{ctStanFit}
\usage{
ctStanFit(datalong, ctstanmodel, stanmodeltext = NA, iter = 1000,
  intoverstates = TRUE, binomial = FALSE, fit = TRUE,
  intoverpop = FALSE, stationary = FALSE, plot = FALSE,
  derrind = "all", optimize = FALSE, optimcontrol = list(),
  nlcontrol = list(), nopriors = FALSE, chains = 1,
  cores = "maxneeded", inits = NULL, forcerecompile = FALSE,
  savescores = TRUE, gendata = TRUE, control = list(), verbose = 0,
  ...)
}
\arguments{
\item{datalong}{long format data containing columns for subject id (numeric values, 1 to max subjects), manifest variables, 
any time dependent (i.e. varying within subject) predictors, 
and any time independent (not varying within subject) predictors.}

\item{ctstanmodel}{model object as generated by \code{\link{ctModel}} with type='stanct' or 'standt', for continuous or discrete time
models respectively.}

\item{stanmodeltext}{already specified Stan model character string, generally leave NA unless modifying Stan model directly.
(Possible after modification of output from fit=FALSE)}

\item{iter}{number of iterations, half of which will be devoted to warmup by default when sampling.
When optimizing, this is the maximum number of iterations to allow -- convergence hopefully occurs before this!}

\item{intoverstates}{logical indicating whether or not to integrate over latent states using a Kalman filter. 
Generally recommended to set TRUE unless using non-gaussian measurement model.}

\item{binomial}{Deprecated. Logical indicating the use of binary rather than Gaussian data, as with IRT analyses.
This now sets \code{intoverstates = FALSE} and the \code{manifesttype} of every indicator to 1, for binary.}

\item{fit}{If TRUE, fit specified model using Stan, if FALSE, return stan model object without fitting.}

\item{intoverpop}{if TRUE, integrates over population distribution of parameters rather than full sampling.
Allows for optimization of non-linearities and random effects.}

\item{stationary}{Logical. If TRUE, T0VAR and T0MEANS input matrices are ignored, 
the parameters are instead fixed to long run expectations. More control over this can be achieved
by instead setting parameter names of T0MEANS and T0VAR matrices in the input model to 'stationary', for
elements that should be fixed to stationarity.}

\item{plot}{if TRUE, a Shiny program is launched upon fitting to interactively plot samples. 
May struggle with many (e.g., > 5000) parameters, and may leave sample files in working directory if sampling is terminated.}

\item{derrind}{vector of integers denoting which latent variables are involved in dynamic error calculations.
latents involved only in deterministic trends or input effects can be removed from matrices (ie, that
obtain no additional stochastic inputs after first observation), speeding up calculations. 
If unsure, leave default of 'all' ! Ignored if intoverstates=FALSE.}

\item{optimize}{if TRUE, use \code{\link{optimstan}} function for maximum a posteriori estimates.}

\item{optimcontrol}{list of parameters sent to \code{\link{optimstan}} governing optimization / importance sampling.}

\item{nlcontrol}{List of non-linear control parameters. 
\code{lineardynamics} defaults to "auto", but may also be a logical. Set to TRUE to use estimator that assumes linear dynamics, 
FALSE to use non-linear integration. "auto" attempts to select the appropriate choice.
\code{nlmeasurement} defaults to "auto", but may also be a logical. Set to TRUE to use non linear measurement model estimator, 
FALSE to use linear model. "auto" attempts to select the appropriate choice. Non-linear methods are slower but applicable to both linear
and non linear cases.
\code{ukffull} may be TRUE or FALSE. If FALSE, nonlinear filtering via the unscented filter uses a minimal number of sigma points,
that does not capture skew in the resulting distribution. 
\code{maxtimestep} must be a positive numeric,  specifying the largest time
span covered by the numerical integration. The large default ensures that for each observation time interval, 
only a single step of exponential integration is used. When \code{maxtimestep} is smaller than the observation time interval, 
the integration is nested within an Euler like loop. 
Smaller values may offer greater accuracy, but are slower and not always necessary. Given the exponential integration,
linear model elements are fit exactly with only a single step. 
\code{ukfspread} should be a small positive numeric value, indicating what fraction of a standard deviation to 
use for unscented sigma points. Values between 1e-6 and 2 have tended to be reasonable, in our experience. 
In general, larger values may not make sense when using the default of \code{ukffull=FALSE}.}

\item{nopriors}{logical. If TRUE, any priors are disabled -- sometimes desirable for optimization.}

\item{chains}{number of chains to sample, during HMC or post-optimization importance sampling.}

\item{cores}{number of cpu cores to use. Either 'maxneeded' to use as many as available,
up to the number of chains, or a positive integer.}

\item{inits}{vector of parameter start values, as returned by the rstan function \code{\link[rstan]{unconstrain_pars}} for instance.}

\item{forcerecompile}{logical. For development purposes. 
If TRUE, stan model is recompiled, regardless of apparent need for compilation.}

\item{savescores}{Logical. If TRUE, latent process values are saved in output. For datasets with many latent processes 
or time points, will increase file size substantially.}

\item{gendata}{Logical -- generate random data sets per sample? For later plotting / model checking.
For datasets with many manifest variables or time points, may increase file size substantially. Needs to be set FALSE for win32.}

\item{control}{List of arguments sent to \code{\link[rstan]{stan}} control argument, 
regarding warmup / sampling behaviour. Unless specified, values used are:
list(adapt_delta = .8, adapt_window=2, max_treedepth=10, adapt_init_buffer=2, stepsize = .001)}

\item{verbose}{Integer from 0 to 2. Higher values print more information during model fit -- for debugging.}

\item{...}{additional arguments to pass to \code{\link[rstan]{stan}} function.}
}
\description{
Fits a ctsem model specified via \code{\link{ctModel}} with type either 'stanct' or 'standt', using Bayseian inference software
Stan.
}
\examples{
\dontrun{
#test data with 2 manifest indicators measuring 1 latent process each, 
# 1 time dependent predictor, 3 time independent predictors
head(ctstantestdat) 

#generate a ctStanModel
model<-ctModel(type='stanct',
n.latent=2, latentNames=c('eta1','eta2'),
n.manifest=2, manifestNames=c('Y1','Y2'),
n.TDpred=1, TDpredNames='TD1', 
n.TIpred=3, TIpredNames=c('TI1','TI2','TI3'),
LAMBDA=diag(2))

#set all parameters except manifest means to be fixed across subjects
model$pars$indvarying[-c(19,20)] <- FALSE

#fit model to data (takes a few minutes - but insufficient 
# iterations and max_treedepth for inference!)
fit<-ctStanFit(ctstantestdat, model, iter=200, chains=2, 
control=list(max_treedepth=6))

#output functions
summary(fit) 

plot(fit)

}
}
